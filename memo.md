## [最新の GoF パターン](https://www.informit.com/articles/article.aspx?p=1404056)

- 削除されたもの
  - singleton, Adapter, Bridge, Chain of Responsibility, Memento, Observer

```
These were the categories:

Core: Composite, Strategy, State, Command, Iterator, Proxy, Template Method, Facade

Creational: Factory, Prototype, Builder, Dependency Injection

Peripheral: Abstract Factory, Visitor, Decorator, Mediator, Type Object, Null Object, Extension Object

Other: Flyweight, Interpreter
```

## 雑多なメモ

- 「持っている関係(has-a)」のことを集約という

```java
class Color {
	// ...
}

// Fruit クラスの color フィールドは Color クラス型のため集約
class Fruit {
	Color color;
}
```

- デザインパターンの目標の一つはプログラミングを再利用可能にすること
    - どうやってプログラムを部品として再利用するかを考えている

- プログラムを「完成品としてみない」
    - 「今後拡張していくもの、変更を加えていくもの」としてみる

- クラス階層について考える時に、スーパークラス視点で考える
  - スーパークラスで抽象メソッドを宣言する場合
    - サブクラスがそのメソッドを実装することを期待する(要請する)

- サブクラスにはスーパークラスで宣言されている抽象メソッドを実装するという責任が生じる = subclass responsibility

- デザインパターンを理解するためには、クラスやインターフェースの相互関係に目を向ける
  - 複数のクラスやインターフェースが個々の役割を持ち、互いに関連しながら動作するため
    - 白雪姫が1人だと劇は成立しない

---
## 各パターンの要約

- Iterator の本質は「背後の構造を意識させずに1つずつ取り出せるという抽象化」

- Adapter(Wrapper) の本質は「すでに提供されているものと必要なもののズレを埋めること」
  - 異なるインターフェースを持つクラス同士をつなぐ
  - テストされ実績が十分でバグの少ない、すでに存在しているクラスを再利用する時に使う
    - 新しいインターフェース(API)に適合させようとする時、既存のソースを修正しようと考えてしまう
    - 既存のものを修正する場合は、もう一度テストが必要になる
    - ***テストコードがあり適切にテストができるなら影響範囲によっては既存のものを修正しても良さそう***

- Template Method の本質は「処理の順序と実装の分離」
  - スーパークラス(抽象クラス)で処理の枠組みを定め、サブクラスでその具体的内容を定める

- Factory Method(Virtual Constructor) の本質は「インスタンスを生成のための枠組みと実際のインスタンス生成の分離」
  - インスタンス生成に Template Method パターンを利用したもの
  - 枠組みに関するパッケージは、実際に生成するパッケージに依存しない
  - 保守する人のために、コメント等に使用してるデザインパターン名や意図を記載しておく(Template Method パターンも)
    - 1つのクラスでは動作がわからない作りとなるため
    - スーパークラスで動作の骨組みを理解し、抽象メソッドを実装しているクラスのコードを読む必要がある

- Singleton の本質は「インスタンスが1つしか存在しないことの保証」
  - 現代の文脈で見直した際に削除された
    - 実質的にはグローバル変数で便利さより副作用が上回る
      - 何かを入れて、別のところで取り出すので悪しきグローバル変数と同じ
      - メソッド内で Singleton のインスタンスを探して使うとスコープが突然広がり、意識しないといけない物が増える(無関係に思えるところに依存関係が生じる)
      - Singleton の状態をリセットしないとテストコード間にも依存関係が生まれる
    - プロセスの中で単一にしても、複数のサーバ(VM)に対してリクエストする時代なので意味がない

- Prototype の本質は「クラスからではなく、インスタンスをコピーして新しいインスタンスを生成する」

- Builder の本質は「構造を持ったインスタンスを段階的に組み上げていくこと??」
  - Builder interface では構成するための抽象メソッドを書く
  - Director クラスは Builder のインターフェース(API)をつかってインスタンスを生成する
    - ただし ConcreteBuilder に依存したプログラミングは行わない
  - Client(Main クラス等)は Builder interface のメソッドは知らず、 Director クラスのメソッドを呼び出す

- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」
- a の本質は「」


